# 정렬(Sorting)
* 정렬은 자료들을 크기 순서대로(오름차순으로) 나열하는 것이다.   
    >입력 예:  7  9  6  2  10  4  5  9  8   
    >정렬:   2  4  5  6  7  8  9  9  10   

* 정렬은 여러 응용분야 사용되는 매우 기본적인 문제이다.

* 정렬 알고리즘은 크게 **간단한 정렬 알고리즘**과 **고급 정렬 알고리즘**으로 나뉜다.
    >간단한 정렬 알고리즘: 선택 정렬, 버블 정렬, 삽입 정렬   

    >고급 정렬 알고리즘:

      (1) 분할과 정복 알고리즘(Divide and Conquer): 병합정렬(merge sort), 퀵정렬(quick sort)
      (2) 힙정렬(heapsort): 우선순위 큐(priority queue)와 힙, 힙정렬
      (3) 기수정렬(radix sort) 


정렬 알고리즘 분류
-------------
* Stable 정렬 알고리즘
    >정렬 할 자료들(입력 자료) 중 동일한 두 자료의 상대적인 위치가 정렬 후에도 유지되는 정렬 알고리즘   
    >ex) C5, **A1**, T8, B4, **A3** => **A1**, **A3**, B4, C5, T8

* In-place 정렬 알고리즘
    >정렬 할 자료를 저장하는 메모리 공간이외에 추가로 사용하는 메모리 공간이 O(1)인 정렬 알고리즘   
    >ex) C5, **A1**, T8, B4, **A3** => **A3**, **A1**, B4, C5, T8


선택 정렬(_Selection Sort_)
-------------
**(1)** 정렬하고자 하는 배열 A[1 … n]에서 가장 큰(작은) 원소를 찾는다.   
**(2)** (1)과정에서 찾은 가장 큰(작은) 원소와 배열의 끝자리A[n](작은 원소의 경우 A[0])와 자리를 바꾼다.   
**(3)** 교환되어 배열을 맨 뒷자리(앞자리)로 간 원소는 자기 자리를 찾으므로 제외시키고, 나머지 원소들로 위와 같은 작업을 반복한다. => 원소가 하나 남으면 정렬 작업을 종료한다.

>ex) [30 12 15 **57** 17] -> [30 12 15 17 **57**] -> [**30** 12 15 57 15] ->[17 12 15 **30** 57] -> [15 12 **17** 30 57] -> [12 **15** 17 30 57] -> [**12** **15** **17** **30** **57**]

### ex) 선택 정렬(_Selection Sort_)
``` java
void selectionSort(int a[], int n) {
    for(int i = n-1; i > 0; i--) {  //---for루프 n-1번 반복
        int index = 0;
        for(int j = 1; j <= i; j++) //---가장 큰 수를 찾기 위한 비교횟수 : i
            if(a[index] < a[j)
                index = j;
    int temp = a[index];
    a[index] = a[i];               //---(3)교환은 상수시간 작업
    a[i] = temp;
    }
}
```
>=> 전체 원소 비교횟수: n-1 + n-2 + n-3 + ... + 2 + 1 = n(n-1)/2   
=>최악의 경우 시간복잡도(원소 비교횟수= n-1 + n-2 + …+ 2 + 1 = n(n-1)/2 = O(n^2)   
=>가장 좋은  경우(best case) 시간 복잡도 = 평균적인 경우 시간복잡도





* 크기 n인 모든 입력에 대한 평균적인 수행시간 (_average-case running time_)
>   ><span style="color:red">평균적인 수행시간을 분석하는 것은 매우 어렵다.</span>
* 크기 n인 모든 입력 중 최악의 경우에 대한 수행시간(_worst-case running time_)
>   >장점: 최악의 입력이 무엇인지는 비교적 쉽게 추정 가능하므로 수행시간 측정이 용이하다.   
단점: 정확한 수행시간이 아닌 일종의 **수행시간의 최대값**만을 제시.
실제 상황에 최악의 수행시간이 중요한 경우가 많다. (항공기 제어, 교통 제어, IP lookup 등에서 실제로 유용함)
* 보통 _worst-case running time_ 을 분석한다.
* 알고리즘의 수행시간은 유사(Pseudo) 코드에서 실행되는 기본 연산의 개수로 정의된다.
>   >기본 연산: 알고리즘의 수행시간에 가장 큰 영향을 미치는 연산
              (비교연산, 사칙연산 등)
- - -
최악의 경우 수행 시간 (_worst case running time_)
-------------
  
* 수행되는 작업의 양(기본 연산의 수)은 입력의 크기 n에 비례한다.
* 입력의 크기가 n일 때, 실행되는 기본연산의 수는 입력 형태(구현된 코드)에 따라 달라진다.
* 최악의 경우 수행시간: 크기가 n인 모든 가능한 입력에 대하여 실행되는 기본연산 수의 최대값
  * W(n)으로 표기.
> 알고리즘의 수행시간 (_running time_)은 T(n)으로 표기.

>   >T(n) = 실행되는 기본연산의 개수  ≤  W(n)

평균적인 경우 수행 시간 (_average case running time_)
-------------
  
* 모든 입력에 대한 분석(Analysis for all inputs)
* 크기가 n인 모든 입력에 대하여 실행되는 기본 연산의 수의 평균
  * A(n)으로 표기.
- - -
### ex) 순차탐색_Sequential Search
``` c
int seqSearch(int A[], int n, int K) { 
  int ans;
  ans = -1;
  for(int index = 0; index < n; index++)
    if (K == A[index]) {
      ans = index;
      break;
    }
  return ans;
}
```

>   >기본 연산: K와 배열 원소와의 비교   
입력크기 n: 배열에 있는 원소들의 수
* 최악의 경우 수행 시간: W(n) = n
* 알고리즘 수행시간: T(n) ≤ n
- - -
점근적(Asymptotic) 분석
-------------
* 데이터의 개수 n → ∞ 일때 수행시간이 증가하는 growth rate로 시간복잡도를 표현하는 기법.
* Θ-표기, Ο-표기 등을 사용

### 함수의 증가율 비교 ex) 1

<img src="https://user-images.githubusercontent.com/62328584/93768672-b86fab80-fc54-11ea-8bc5-05847ee83f1f.JPG" width="450px" height="300px"></img><br/>

### 함수의 증가율 비교 ex) 2
<img src="https://user-images.githubusercontent.com/62328584/93768964-26b46e00-fc55-11ea-9f10-9f3f273bb055.JPG" width="450px" height="300px" alt="growth-rate표"></img><br/>

증가율에 의한 함수 표기법
-------------
* “Big-Theta” 표기("세타"라고 읽는다.)
  * Θ(f(n)) : n ≥ n0인 모든 정수 n에 대하여, c1 f(n) ≤ g(n) ≤ c2 f(n)을 만족하는 세 수 n0, c1, c2가 존재하면 g(n) ∈ Θ(f(n))을 만족하는 함수 g의 집합   
                
    직관적 의미: g(n) ∈ Θ(f(n)) [혹은 g(n) = Θ(f(n))이라고 말하기도 함] ⇒ g는 f 와 같은 정도로 증가한다.
>   >ex) 5n^2+4n의 증가율은 n^2의 증가율과 점근적인 의미에서 같으므로 5n^2+4n = Θ(n^2)이다.   
Θ(n^2)은 n^2, 6n^2-49, 2n^2+3nlogn 등을 포함한다.   
=> Θ(n^2)은 최고차항의 차수가 f(n)과 **일치**하는 함수의 집합이다.

* “Big-O” 표기("오"라고 읽는다.)
  * O(f(n)) : 어떤 실수 c와 음이 아닌 정수 n0에 대하여, n ≥ n0인 모든 n에 대하여 g(n) ≤ c f(n)을 만족하는 함수 g의 집합

    직관적 의미: 함수 g는 함수 f 보다 빠르게 증가하지 않는다. 상수 비율의 차이는 무시
>   >ex) 5n^2+4n의 증가율은 n^2의 증가율과 점근적인 의미에서 같으므로 5n^2+4n = O(n^2)이다.   
O(n^2)은 n^2, 3n^2-50, 5n, 2nlogn+3n, 500 등을 포함한다.   
=> O(f(n))은 최고차항의 차수가 f(n)과 일치하거나 더 **작은** 함수의 집합이다.

* “Big-Omega” 표기("오메가"라고 읽는다.)
  * Ω(f(n)) : 어떤 실수 c와 음이 아닌 정수 n0에 대하여, n ≥ n0인 모든 n에 대하여 g(n) ≥ c f(n)을 만족하는 함수 g의 집합

    직관적 의미: g(n) ∈ Ω(f(n)) [혹은 g(n) = Ω(f(n))이라고 말하기도 함] ⇒ g는 f 보다 느리게 증가하지 않는다.
>   >ex) 5n^2+4n의 증가율은 n^2의 증가율과 점근적인 의미에서 같으므로 5n^2+4n = Ω(n^2)이다.  
또한, 9n^3의 증가율은 n^2의 증가율보다 크기 때문에 9n^3 = Ω(n^2)이라해도 무방하다.   
Ω(n^2)은 n^2, 4n^2-199, 5n^3+45, 2n^2logn+1 등을 포함한다.   
=> Ω(f(n))은 최고차항의 차수가 f(n)과 일치하거나 더 **큰** 함수의 집합이다.   

- - -
         
>	>본 자료는 한국외국어대학교 컴퓨터.전자시스템공학전공 김희철 교수님의 [알고리즘]강의자료를 참고하여 만들었습니다.