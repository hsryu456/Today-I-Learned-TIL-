# 정렬(Sorting)
* 정렬은 자료들을 크기 순서대로(오름차순으로) 나열하는 것이다.   
    >입력 예:  7  9  6  2  10  4  5  9  8   
    >정렬:   2  4  5  6  7  8  9  9  10   

* 정렬은 여러 응용분야 사용되는 매우 기본적인 문제이다.

* 정렬 알고리즘은 크게 **간단한 정렬 알고리즘**과 **고급 정렬 알고리즘**으로 나뉜다.
    >간단한 정렬 알고리즘: 선택 정렬, 버블 정렬, 삽입 정렬   

    >고급 정렬 알고리즘:

      (1) 분할과 정복 알고리즘(Divide and Conquer): 병합정렬(merge sort), 퀵정렬(quick sort)
      (2) 힙정렬(heapsort): 우선순위 큐(priority queue)와 힙, 힙정렬
      (3) 기수정렬(radix sort) 


정렬 알고리즘 분류
-------------
* Stable 정렬 알고리즘
    >정렬 할 자료들(입력 자료) 중 동일한 두 자료의 상대적인 위치가 정렬 후에도 유지되는 정렬 알고리즘   
    >ex) C5, **A1**, T8, B4, **A3** => **A1**, **A3**, B4, C5, T8

* In-place 정렬 알고리즘
    >정렬 할 자료를 저장하는 메모리 공간이외에 추가로 사용하는 메모리 공간이 O(1)인 정렬 알고리즘   
    >ex) C5, **A1**, T8, B4, **A3** => **A3**, **A1**, B4, C5, T8


선택 정렬(_Selection Sort_)
-------------
**(1)** 정렬하고자 하는 배열 A[1 … n]에서 가장 큰(작은) 원소를 찾는다.   
**(2)** (1)과정에서 찾은 가장 큰(작은) 원소와 배열의 끝자리A[n](작은 원소의 경우 A[0])와 자리를 바꾼다.   
**(3)** 교환되어 배열을 맨 뒷자리(앞자리)로 간 원소는 자기 자리를 찾으므로 제외시키고, 나머지 원소들로 위와 같은 작업을 반복한다. => 원소가 하나 남으면 정렬 작업을 종료한다.

>ex) [30 12 15 **57** 17] -> [30 12 15 17 **57**] -> [**30** 12 15 17 57] ->[17 12 15 **30** 57] -> [15 12 **17** 30 57] -> [12 **15** 17 30 57] -> [**12** **15** **17** **30** **57**]

### ex) 선택 정렬(_Selection Sort_)
``` java
void selectionSort(int a[], int n) {
    for(int i = n-1; i > 0; i--) {  //---for루프 n-1번 반복
        int index = 0;
        for(int j = 1; j <= i; j++) //---가장 큰 수를 찾기 위한 비교횟수 : i
            if(a[index] < a[j)
                index = j;
    int temp = a[index];
    a[index] = a[i];               //---(3)교환은 상수시간 작업
    a[i] = temp;
    }
}
```
>=> 전체 원소 비교횟수: n-1 + n-2 + n-3 + ... + 2 + 1 = n(n-1)/2   
=>최악의 경우 시간복잡도(원소 비교횟수= n-1 + n-2 + …+ 2 + 1 = n(n-1)/2 = O(n^2)   
=>가장 좋은 경우(best case) 시간 복잡도 = 평균적인 경우 시간복잡도
- - -

버블 정렬(_Bubble Sort_)
-------------
  
**(1)** 정렬하고자 하는 배열 A[1 … n]상의 인접한 두 원소를 비교한다.   
**(2)** 뒤에 있는 원소가 앞의 원소보다 작은 경우, 두 원소를 교환한다.    
**(3)** (1), (2) 단계 수행 후 최대값이 마지막으로 이동하므로, 마지막 원소는 정렬대상에서 제외된다. => 원소가 하나 남으면 정렬 작업을 종료한다.
> >왼쪽부터 이웃한 두 수를 비교, 순서가 제대로 되어 있지 않으면 하나하나 바꾸어나간다.

>ex) [30 12 15 57 17] -> [**30** **12** 15 57 17] -> [12 **30** **15** 57 17] ->[12 15 **30** **57** 17] -> [12 15 30 **57** **17**] -> [12 15 30 17 **57**] -> [**12** **15** 30 17 57] -> [12 **15** **30** 17 57] -> [12 15 **30** **17** 57] -> [12 15 17 **30** **57**] -> [**12** **15** **17** **30** **57**]


### ex) 버블 정렬(_Bubble Sort_)
``` java
void bubbleSort(int a[], int n) {
  for(i = n-1; i > 0; i--)
    for(j = 0; j < i; j++)
      if(a[j] > a[j+1]) {     //a[j] > a[j+1]일 경우, a[j]와 a[j+1]을 교환
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
      }
}
```
>=> 전체 원소 비교횟수: n-1 + n-2 + n-3 + ... + 2 + 1 = n(n-1)/2   
=>최악의 경우 시간복잡도: 원소 비교횟수= n-1 + n-2 + …+ 2 + 1 = n(n-1)/2 = O(n^2)   
=>가장 좋은 경우(best case) 시간 복잡도 = 평균적인 경우 시간복잡도 O(n^2)

- 예시로 제시한 버블 정렬 알고리즘은 수행을 시작할 때나 중간에 배열이 이미 정렬되어 있는 상태일지라도 인접한 수들의 비교를 계속 진행한다.(무의미한 순환이 계속된다.) => **개선된 알고리즘 필요.** 

### ex) 개선된 버블 정렬(_Bubble Sort_)
``` java
void bubbleSort(int a[], int n) {
  for(i = n-1; i > 0; i--) {
    int sorted = 1;   //bool sorted = true;
    for(j = 0; j < i; j++)
      if(a[j] > a[j+1]) {
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
        sorted = 0;   //sorted = false;
      }
    if(sorted == 1)   //if(sorted)
      break;
  }
}
```
- for 루프가 시작되기 직전에 매번 'sorted'라는 표식자르 true로 설정하고, for 루프가 진행되는 동안 변하는지 확인한다.   
- a[j] <-> a[j+1]의 교환이 일어나면 sorted는 false로 바뀐다.
- 인접한 수끼리의 교환이 일어나지 않았을 경우(sorted = true) 배열은 이미 정렬되어 있다는 것을 의미하기 때문에 더 이상의 반복을 진행하지 않고, 해당 루프를 탈출한다.
>=> 전체 원소 비교횟수: n-1 + n-2 + n-3 + ... + 2 + 1 = n(n-1)/2   
=>최악의 경우 시간복잡도 = 역순으로 정렬되어 있는 입력 O(n^2)      
=>가장 좋은 경우(best case) 시간 복잡도 = 정렬되어 있는 입력 O(n)

- - -
삽입 정렬(_Insertion Sort_)
-------------
* 이미 정렬되어 있는 i개 배열에 하나의 원소를 더하여, 정렬된 i+1개의 배열을 만드는 과정을 반복한다.
* 선택 정렬과 버블 정렬이 n개의 배열에서 시작하여 크기를 하나씩 줄여나가는 것과는 반대로, 삽입 정렬은 한 개의 배열에서 시작하여 크기를 늘려나가는 정렬이다.

ex)   
><img src="https://user-images.githubusercontent.com/62328584/94325829-565bd100-ffdb-11ea-9d84-cc46f852ca06.JPG" width="750px" height="300px"></img><br/>

### ex) 삽입 정렬(_Insertion Sort_)
``` java
void insertionSort(int a[], int n) {
  for(i = 1; i < n; i++) {    //a[1]부터 차례대로 삽입하여 정렬
    int temp = a[i];
    for(j =i-1; j >= 0; j--) {  //정렬되어 있는 a[0...i-1]에 a[i]삽입
      if(a[j] > temp) {
        a[j+1] = a[j];
      else
        break;
      }
    a[j+1] = temp;
  }
}
```
>=>최악의 경우 시간복잡도: 역순으로 정렬되어 있는 입력 = n-1 + n-2 + …+ 2 + 1 = n(n-1)/2 = O(n^2)   
=>가장 좋은 경우 시간 복잡도: 정렬되어 있는 입력 = O(n)

간단한 정렬알고리즘 Summary
-------------

|              | Best Case | Worst Case | Average Case | Stable | Inplace |
|:------------:|:------------:|:-----:|:------:|:--------------:|:--------:|
| Selection Sort | O(n^2)  | O(n^2) | Θ(n^2) | ?? | Yes |
| Bubble Sort | O(n^2) -> O(n) | O(n^2)  |Θ(n^2) | Yes | Yes |
| Insertion Sort | O(n) | O(n^2) | Θ(n^2) | Yes | Yes |

* 장점: 이해하기 쉽다. 코딩하기 쉽다. 입력이 적은 경우엔 매우 빠르다.
* 단점: 입력이 클 경우 매우 느려진다.

- - -

# 분할과 정복(_Divide and Conquer_)

* 큰 (입력의) 문제를 작은 (입력의) 문제(subproblem)들로 나눈다.   -----(1)
* 단계 1의 작은 문제들의 해를 재귀적으로(recursively) 구한다. -----(2)
* 단계 2에서 구한 작은 문제들의 해를 이용하여 원래 문제의 해를 구한다.

병합 정렬(_Merge Sort_)
-------------
**(1)** 입력을 반으로 나눈다.  
**(2)** 반으로 나눈 전반부와 후반부를 각각 독립적으로 정렬한다.  
**(3)** (1), (2) 단계 수행 후 정렬된 두 부분을 합쳐(병합하여) 하나의 정렬된 배열을 얻는다.
> >전반부와 후반부로 나눈 배열을 정렬할 때 역시 크기를 반으로 줄여가며 정렬한다.(재귀적)

>ex) [31 3 65 73 8 11 20 29 48 15] -> [31 3 65 73 8] [11 20 29 48 15] -> [**3** **8** **31** **65** **73**] [_11 15 20 29 48_] -> [**3** **8** _11_ _15_ _20_ _29_ **31** _48_ **65** **73**] 

ex)   
><img src="https://user-images.githubusercontent.com/62328584/94353116-41993f00-00a8-11eb-88c7-0b41a17583fd.JPG" width="750px" height="300px"></img><br/>

### ex) 병합 정렬(_Merge Sort_)
``` java
void mergeSort(int A[], int first, int last) {
  if(first < last) {
    int mid = (first + last) / 2;
    mergeSort(A, first, mid);
    mergeSort(A, mid+1, last);
    merge(A, first, mid, last);
  }
}
```
``` java
void merge(int A[], int first, int mid, int last) {
  int i = start;
  int j = mid + 1;
  int k = start;
  int[] tmp = new int[A.length];

  while(i <= start && j <= last) {
    if(A[i] <= A[j]) {
      tmp[k] = A[i];
      i++;
    } else {
      tmp[k] = A[j];
      j++;
    }
    k++;
  }
  if(i > mid) {
    for(int t = j; t <= end; t++, k++) {
      tmp[k] = A[t];
    }
  }
  for(int t = start; t <= end; t++) {
    A[t] = tmp[t];
  }
}
```
  > >병합 정렬 단점:
   - merge 할 때 O(n) 추가적인 메모리가 필요하다.
   - 재귀 호출 시  O(log n) 스택 메모리가 필요하다.

시간복잡도
-------------

* “Big-Theta” 표기("세타"라고 읽는다.)
  * Θ(f(n)) : n ≥ n0인 모든 정수 n에 대하여, c1 f(n) ≤ g(n) ≤ c2 f(n)을 만족하는 세 수 n0, c1, c2가 존재하면 g(n) ∈ Θ(f(n))을 만족하는 함수 g의 집합   
                
    직관적 의미: g(n) ∈ Θ(f(n)) [혹은 g(n) = Θ(f(n))이라고 말하기도 함] ⇒ g는 f 와 같은 정도로 증가한다.
>   >ex) 5n^2+4n의 증가율은 n^2의 증가율과 점근적인 의미에서 같으므로 5n^2+4n = Θ(n^2)이다.   
Θ(n^2)은 n^2, 6n^2-49, 2n^2+3nlogn 등을 포함한다.   
=> Θ(n^2)은 최고차항의 차수가 f(n)과 **일치**하는 함수의 집합이다.

* “Big-O” 표기("오"라고 읽는다.)
  * O(f(n)) : 어떤 실수 c와 음이 아닌 정수 n0에 대하여, n ≥ n0인 모든 n에 대하여 g(n) ≤ c f(n)을 만족하는 함수 g의 집합

    직관적 의미: 함수 g는 함수 f 보다 빠르게 증가하지 않는다. 상수 비율의 차이는 무시
>   >ex) 5n^2+4n의 증가율은 n^2의 증가율과 점근적인 의미에서 같으므로 5n^2+4n = O(n^2)이다.   
O(n^2)은 n^2, 3n^2-50, 5n, 2nlogn+3n, 500 등을 포함한다.   
=> O(f(n))은 최고차항의 차수가 f(n)과 일치하거나 더 **작은** 함수의 집합이다.

* “Big-Omega” 표기("오메가"라고 읽는다.)
  * Ω(f(n)) : 어떤 실수 c와 음이 아닌 정수 n0에 대하여, n ≥ n0인 모든 n에 대하여 g(n) ≥ c f(n)을 만족하는 함수 g의 집합

    직관적 의미: g(n) ∈ Ω(f(n)) [혹은 g(n) = Ω(f(n))이라고 말하기도 함] ⇒ g는 f 보다 느리게 증가하지 않는다.
>   >ex) 5n^2+4n의 증가율은 n^2의 증가율과 점근적인 의미에서 같으므로 5n^2+4n = Ω(n^2)이다.  
또한, 9n^3의 증가율은 n^2의 증가율보다 크기 때문에 9n^3 = Ω(n^2)이라해도 무방하다.   
Ω(n^2)은 n^2, 4n^2-199, 5n^3+45, 2n^2logn+1 등을 포함한다.   
=> Ω(f(n))은 최고차항의 차수가 f(n)과 일치하거나 더 **큰** 함수의 집합이다.   

- - -
         
>	>본 자료는 한국외국어대학교 컴퓨터.전자시스템공학전공 김희철 교수님의 [알고리즘]강의자료를 참고하여 만들었습니다.
